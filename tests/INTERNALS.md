# Test Internals

Technical details about the relais test infrastructure.

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────────────┐
│                         Test Files (.cpp)                           │
│  test_base_repository.cpp      BaseRepository (no cache) + updateBy │
│  test_redis_repository.cpp     RedisRepository (L2 cache)           │
│  test_decl_list_cache.cpp      ListMixin (L1 lists)                  │
│  test_cached_repository.cpp    CachedRepository (L1 cache)          │
│  test_partial_key.cpp          PartialKey (composite PK, partitions) │
│  test_generated_wrapper.cpp    Struct + EntityWrapper + ListWrapper  │
└─────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────┐
│                       TestRepositories.h                            │
│  Configs: Uncached, L1Only, L2Only, Both, ShortTTL, WriteThrough…  │
│  Entity repos: L2TestItemRepo, L1TestUserRepo, L2TestPurchaseRepo… │
│  List repos: TestArticleListRepository, TestPurchaseListRepository  │
│  (inherit from relais::Repository<...> + ListCacheRepository)    │
└─────────────────────────────────────────────────────────────────────┘
                              │
                    ┌─────────┴─────────┐
                    ▼                   ▼
┌───────────────────────────┐  ┌───────────────────────────┐
│    Entity layer            │  │    Drogon ORM layer       │
│    TestItem.h (pure struct)│  │    TestItemModel.h        │
│    TestUser.h              │  │    Mock_* models          │
│    TestArticle.h           │  │    (manual + mocks)       │
│    TestPurchase.h          │  │    TestEventModel.h       │
│    TestEvent.h             │  │    (composite PK: id+region)│
│    TestOrder.h             │  │    - DB row mapping       │
│    TestEntities.h          │  │    - CoroMapper interface │
│    - EntityWrapper aliases │  │                           │
│    generated/*Mapping.h    │  │                           │
│    - fromModel/toModel     │  │                           │
└───────────────────────────┘  └───────────────────────────┘
                    │                   │
                    └─────────┬─────────┘
                              ▼
┌─────────────────────────────────────────────────────────────────────┐
│                        test_helper.h                                │
│  - initTest(): Drogon + PostgreSQL + Redis initialization           │
│  - TransactionGuard: RAII test isolation (BEGIN/ROLLBACK + flush)   │
│  - sync(): Coroutine synchronous execution                          │
│  - insertTestItem/User/Purchase/Article: Direct DB helpers          │
│  - getCacheSize<Repo>(), forceFullCleanup<Repo>()                  │
└─────────────────────────────────────────────────────────────────────┘
```

## Key Components

### test_helper.h

#### `initTest()`

Initializes Drogon for testing:
1. Registers PostgreSQL client with hardcoded config
2. Registers Redis client (127.0.0.1:6379)
3. Starts Drogon event loop in a background thread
4. Waits for the app to be running
5. Waits 500ms for DB connections to initialize

**Important**: Called once per test run (guarded by atomic flag).

#### `TransactionGuard`

RAII class for test isolation:
```cpp
TransactionGuard() {
    flushRedis();           // Clear Redis
    execSql("BEGIN");       // Start transaction
}

~TransactionGuard() {
    execSql("ROLLBACK");    // Undo all changes
    flushRedis();           // Clear Redis again
}
```

All database modifications within a test are automatically rolled back.

#### `sync<T>()`

Runs a Drogon coroutine synchronously:
```cpp
auto result = sync(Repository::findById(123));
// Blocks until the coroutine completes
```

Uses `drogon::sync_wait()` internally.

#### Direct DB Helpers

Bypass the repository to set up test data:
- `insertTestItem(name, value, description, is_active)` - Returns generated ID
- `updateTestItem(id, name, value)` - Direct UPDATE
- `deleteTestItem(id)` - Direct DELETE

### TestItemModel.h

Minimal Drogon ORM model implementation. Implements the interface required by `drogon::orm::CoroMapper`:

- Row constructor for SELECT results
- Getters/Setters for all columns
- `sqlForFindingByPrimaryKey()`, `sqlForDeletingByPrimaryKey()`
- `sqlForInserting()` with RETURNING clause
- `outputArgs()`, `updateArgs()` for parameter binding

**Note**: This is a manual implementation. In production, models are generated by `drogon_ctl create model`.

### Entity Structs + EntityWrapper

Each test entity has two layers:

1. **Pure data struct** (e.g., `TestItem.h`): Framework-agnostic struct with `@relais` annotations and `glz::meta` specialization
2. **EntityWrapper alias** (in `TestEntities.h`): `EntityWrapper<Struct, Mapping>` combining the struct with its generated ORM mapping

```cpp
// Pure struct
struct TestItem { int64_t id; std::string name; ... };

// Wrapped for API use
using TestItemEntity = EntityWrapper<TestItem, generated::TestItemMapping>;
```

`EntityWrapper` inherits from the struct and adds:
- `fromModel(Model)` / `toModel(Entity)` — delegated to Mapping
- `toBinary()` / `toJson()` — thread-safe lazy serialization via Glaze
- `getPrimaryKey()` — delegated to Mapping
- `Field` enum, `TraitsType` — from Mapping

Entities are **immutable** (stored as `shared_ptr<const Entity>`). To update:
```cpp
auto original = sync(Repository::findById(id));
TestItemEntity updated = *original;  // Copy
updated.name = "New Name";
sync(Repository::update(id, makeEntity(updated)));
```

### TestRepositories.h

Four repository classes with different cache configurations:

```cpp
// No caching - tests BaseRepository
class UncachedTestItemRepository : public Repository<..., config::Uncached> {};

// L1 only - tests CachedRepository without Redis
class L1TestItemRepository : public Repository<..., config::L1Only> {};

// L2 only - tests RedisRepository
class L2TestItemRepository : public Repository<..., config::L2Only> {};

// Full hierarchy - tests CachedRepository with Redis
class FullCacheTestItemRepository : public Repository<..., config::Both> {};
```

All entity types are `EntityWrapper<Struct, Mapping>` aliases defined in `TestEntities.h`. List types use `ListWrapper<EntityType>`.

## Test Database Schema

```sql
CREATE TABLE relais_test_items (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    value INTEGER NOT NULL DEFAULT 0,
    description TEXT,                    -- nullable
    is_active BOOLEAN NOT NULL DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);
```

## Common Test Patterns

### Basic CRUD Test
```cpp
TEST_CASE("[Repository] CRUD", "[integration][db]") {
    initTest();

    SECTION("findById returns entity") {
        TransactionGuard tx;

        auto id = insertTestItem("Test", 42);
        auto result = sync(Repository::findById(id));

        REQUIRE(result != nullptr);
        REQUIRE(result->name == "Test");
    }
}
```

### Cache Behavior Test
```cpp
SECTION("L1 cache returns stale data") {
    TransactionGuard tx;

    auto id = insertTestItem("Original", 1);

    // Populate cache
    sync(L1Repository::findById(id));

    // Modify directly in DB (bypass cache)
    updateTestItem(id, "Modified", 2);

    // Should still return cached value
    auto cached = sync(L1Repository::findById(id));
    REQUIRE(cached->name == "Original");  // Stale!
}
```

### Invalidation Test
```cpp
SECTION("invalidate clears cache") {
    TransactionGuard tx;

    auto id = insertTestItem("Test", 1);
    sync(Repository::findById(id));  // Populate cache

    updateTestItem(id, "Updated", 2);
    sync(Repository::invalidate(id));  // Clear cache

    auto fresh = sync(Repository::findById(id));
    REQUIRE(fresh->name == "Updated");  // Fresh from DB
}
```

## Debugging Tips

### View SQL Queries
Set Drogon/Trantor log level to TRACE before `initTest()`:
```cpp
trantor::Logger::setLogLevel(trantor::Logger::kTrace);
initTest();
```

### Check Cache State
```cpp
// L1 cache size
REQUIRE(L1Repository::cacheSize() >= 1);

// Clear L1 cache
L1Repository::clearCache();
```

### Test Single Case
```bash
./test_relais_base "[BaseRepository] CRUD Operations" -s
```

## Redis Repository Tests (`test_redis_repository.cpp`)

Comprehensive integration tests for the L2 (Redis) cache layer, organized in 17 logical sections:

| Section | Tag | Content |
|---------|-----|---------|
| 1 | `[item]` | `findById` — cache hit, miss, multi-entity |
| 2 | `[item]` | `create` — insert + populate Redis |
| 3 | `[item]` | `update` — invalidate Redis (lazy reload) |
| 4 | `[item]` | `remove` — invalidate Redis |
| 5 | `[flatbuffer]` | Binary (BEVE) serialization in Redis |
| 6 | `[updateBy]` | Partial field updates with Redis invalidation |
| 7 | `[json]` | `findByIdAsJson` raw JSON retrieval |
| 8 | `[invalidate]` | Explicit `invalidateRedis` + isolation |
| 9 | `[readonly]` | Read-only repository caching |
| 10 | `[cross-inv]` | `Invalidate<>` entity→entity (create, update, delete, FK change) |
| 11 | `[custom-inv]` | `InvalidateVia<>` with custom resolver |
| 12 | `[readonly-inv]` | Cross-invalidation targeting read-only caches |
| 13 | `[list]` + `[fb-list]` | List caching — JSON and BEVE binary |
| 14 | `[list-inv]` + `[list-custom]` | `InvalidateList<>` and list custom resolver |
| 15 | `[list-tracked]` | Tracked pagination + group invalidation + tracking data |
| 16 | `[list-selective]` + `[list-resolver]` | SortBounds Lua selective invalidation + `InvalidateListVia` with GroupKey |
| 17 | `[list-granularity]` | Three granularities: per-page, per-group, full pattern |

## ListDescriptor Tests (`test_decl_list_cache.cpp`)

Integration tests for the declarative L1 list cache system:

| Section | Tag | Content |
|---------|-----|---------|
| 1 | `[query]` | Article list — filters, sorts, limits, empty results |
| 2 | `[itemview]` | Article `ItemView` accessors on cached results |
| 3 | `[query]` | Purchase list — user_id/status filters |
| 4 | `[itemview]` | Purchase `ItemView` accessors |
| 5 | `[sortbounds]` | SortBounds invalidation precision (create, update, delete, filter mismatch) |
| 6 | `[tracker-cleanup]` | `ModificationTracker` cleanup cycles |

## Cross-Invalidation Patterns

The library provides four cross-invalidation mechanisms, all declared via `InvalidateOn`:

### `Invalidate<Cache, &Entity::key>`

Direct entity→entity invalidation. When a source entity is created/updated/deleted, the target cache is invalidated using the extracted key.

```cpp
using Invalidates = InvalidateOn<
    Invalidate<UserCache, &Purchase::user_id>  // Purchase change → invalidate User
>;
```

On **update**, both old and new key values are invalidated (handles FK changes).

### `InvalidateList<ListCache>`

Direct entity→list notification. The source entity change triggers `onEntityModified` on the target list cache, which decides how to invalidate.

```cpp
using Invalidates = InvalidateOn<
    InvalidateList<PurchaseListCache>  // Purchase change → notify PurchaseList
>;
```

### `InvalidateVia<Cache, &Entity::key, &Resolver::resolve>`

Indirect entity→entity with a custom resolver. The resolver maps the source key to one or more target keys.

```cpp
struct PurchaseToArticleResolver {
    static Task<std::vector<int64_t>> resolve(int64_t user_id);
};
using Invalidates = InvalidateOn<
    InvalidateVia<ArticleCache, &Purchase::user_id, &PurchaseToArticleResolver::resolve>
>;
```

### `InvalidateListVia<ListRepo, &Entity::key, &Resolver::resolve>`

Indirect entity→list with a typed `GroupKey` resolver and three granularities.

```cpp
using GroupKey = ArticleListRepo::GroupKey;
using Target = ListInvalidationTarget<GroupKey>;

struct Resolver {
    static Task<vector<Target>> resolve(int64_t user_id);
    // Or: static Task<optional<vector<Target>>> resolve(int64_t user_id);
};

using Invalidates = InvalidateOn<
    InvalidateListVia<ArticleListRepo, &Purchase::user_id, &Resolver::resolve>
>;
```

## `ListInvalidationTarget<GroupKey>` Design

### GroupKey

Each list repository defines its own `GroupKey` struct containing the typed filter values that identify a cache group. This is **not** a Redis key string — it represents the logical group identity.

```cpp
struct GroupKey {
    std::string category;  // matches the filter declared in ListDescriptor
};
```

### `invalidateByTarget(GroupKey, optional<int64_t>)`

Defined in the concrete list repository. Translates the typed `GroupKey` + optional sort value into actual cache operations:

- **`sort_value` present** → calls `invalidateListGroupSelective()` (per-page, Lua-based)
- **`sort_value` absent** → calls `invalidateListGroup()` (per-group, deletes all pages)

### `invalidateAllListGroups()`

Defined in the CRTP hierarchy:
- **BaseRepository**: no-op (no cache to invalidate)
- **RedisRepository**: `SCAN` with pattern `name() + ":list:*"` and `DEL` each match

Called when the resolver returns `std::nullopt` (full pattern invalidation).

### Cache-level agnosticism

The `ListInvalidationTarget<GroupKey>` API is identical regardless of cache level. The resolver always works with typed values — the cache-level-specific logic lives in `invalidateByTarget` and `invalidateAllListGroups` implementations, not in the resolver.

## PartialKey Repositories (`test_partial_key.cpp`)

Tests for repositories where `Key` differs from `Model::PrimaryKeyType` — typically partitioned PostgreSQL tables with a composite PK (e.g., `(id, region)`) but queried by a single unique key (`id`).

### Test Entity: `TestEvent`

- **Table**: `relais_test_events` — range-partitioned by `region` (eu, us, ap)
- **Composite PK**: `(id BIGINT, region VARCHAR)` — `id` from shared sequence, `region` as partition key
- **Repository Key**: `int64_t` (partial — only `id`)
- **Config requires**: `key_is_unique = true` + `makeKeyCriteria<Model>(id)`

### Tested Configurations

| Repository | Config | Cache Level |
|-----------|--------|-------------|
| `UncachedTestEventRepository` | `EventPartialKeyUncached` | None |
| `L1TestEventRepository` | `EventPartialKeyL1` | L1 |
| `L2TestEventRepository` | `EventPartialKeyL2` | L2 |
| `L1L2TestEventRepository` | `EventPartialKeyBoth` | L1+L2 |

### `updateBy` — Criteria-Based for PartialKey

Standard repos use model dirty flags: `setPrimaryKeyOnModel(model, key)` → `mapper.update(model)`. This is **broken** for PartialKey because `setPrimaryKeyOnModel` only sets the partial key (`id`), so `getPrimaryKey()` returns `(id, "")` and Drogon generates `WHERE id=$N AND region=''` → 0 rows.

The fix uses `CoroMapper::updateBy(columns, criteria, values)`:

```cpp
if constexpr (std::is_same_v<Key, typename Model::PrimaryKeyType>) {
    // Standard: model dirty flags
    mapper.update(model);
} else {
    // PartialKey: criteria-based (1 query, no fetch)
    auto criteria = Config::makeKeyCriteria<Model>(id);
    mapper.updateBy(columns, criteria, values...);
}
```

Helpers in `FieldUpdate.h`: `fieldColumnName<Traits>(update)` extracts the quoted column name, `fieldValue<Traits>(update)` extracts the properly-typed value.

### `remove` — Opportunistic Full PK via Cache Hint

For partition pruning, `DELETE WHERE id=$1 AND region=$2` scans 1 partition vs `DELETE WHERE id=$1` scans N. The optimization uses cached entities as hints:

```
CachedRepository::remove(id)
  → hint = getFromCache(id)        // Free L1 check
  → RedisRepository::removeImpl(id, hint)
    → if (!hint && PartialKey) {
        hint = getFromRedis(id)    // ~0.1ms L2 check
      }
    → BaseRepository::removeImpl(id, hint)
      → if (hint) deleteByPrimaryKey(fullPK)  // Pruned: 1 partition
      → else      deleteBy(criteria)           // Scan: N partitions
```

**Performance rule**: Never add a DB round-trip just for partition pruning. Only use full PK when the entity is already available from cache (free or near-free).

### Test Coverage

| Section | Content |
|---------|---------|
| 1 | CRUD: findById, create, update, remove (Uncached) |
| 2 | L1 caching: cache hit, staleness, invalidation |
| 3 | L2 caching: Redis hit, staleness, invalidation |
| 4 | Cross-invalidation: Event as source (→ User L1) |
| 5 | Cross-invalidation: Event as target (Purchase → Event via resolver) |
| 6 | PartialKeyValidator runtime checks |
| 7 | Serialization: JSON + BEVE round-trip |
| 8a | updateBy Uncached: single/multi field, partition preservation, re-fetch |
| 8b | updateBy L1: cache invalidation + re-fetch |
| 8c | updateBy L2: Redis invalidation + re-fetch |
| 8d | updateBy cross-invalidation: Event updateBy → User L1 |
| 9a | remove L1 hint: cache hit vs miss paths |
| 9b | remove L2 hint: Redis hit vs miss paths |
| 9c | remove L1+L2 chain: L1 hit, L1 miss/L2 hit, both miss |