# Smartrepo Tests

Integration tests for the smartrepo library using a real PostgreSQL database and Redis.

## Prerequisites

- PostgreSQL server running locally
- Redis server running locally
- `smartrepo_test` user configured in `pg_hba.conf` with `scram-sha-256` authentication

## Quick Start

```bash
# 1. Initialize test database and generate fixtures
./scripts/setup_tests.sh

# 2. Build tests
cmake -B build && cmake --build build

# 3. Run tests
cd build && ctest -L integration --output-on-failure
```

## Database Setup

The test database uses hardcoded values:

| Setting  | Value            |
|----------|------------------|
| Host     | localhost        |
| Port     | 5432             |
| Database | smartrepo_test   |
| User     | smartrepo_test   |
| Password | smartrepo_test   |

### pg_hba.conf Configuration

Add these lines to your `pg_hba.conf` (before the generic `host all all` lines):

```
local   all   smartrepo_test                      scram-sha-256
host    all   smartrepo_test   127.0.0.1/32       scram-sha-256
host    all   smartrepo_test   ::1/128            scram-sha-256
```

Then restart PostgreSQL:
```bash
sudo systemctl restart postgresql
```

## Test Structure

```
tests/
├── fixtures/
│   ├── generated/           # Auto-generated ORM Mapping structs (generate_entities.py)
│   │   ├── TestItemMapping.h        # Standalone mapping struct
│   │   ├── TestUserMapping.h
│   │   ├── TestArticleMapping.h     # + ListDescriptor
│   │   ├── TestPurchaseMapping.h    # + ListDescriptor
│   │   ├── TestOrderMapping.h
│   │   └── TestEventWrapper.h       # Hand-written PartialKey wrapper (Key≠PK)
│   ├── mocks/               # Hand-maintained mock Drogon models (Mock_*)
│   │   ├── Mock_SmartrepoTestOrders.h   # Mock model for TestOrder
│   │   └── Mock_SmartrepoTestOrders.cc
│   ├── test_helper.h        # Drogon init, TransactionGuard, sync helpers
│   ├── TestItemModel.h      # Drogon ORM model (manual implementation)
│   ├── TestEventModel.h     # Drogon ORM model — composite PK (id, region)
│   ├── TestItem.h            # Pure data struct with @smartrepo annotations
│   ├── TestUser.h            # ...
│   ├── TestArticle.h
│   ├── TestPurchase.h
│   ├── TestOrder.h           # Complex struct (nested, enum, vectors, raw JSON)
│   ├── TestEvent.h           # Pure data struct for partitioned table
│   ├── TestEntities.h       # EntityWrapper<Struct, Mapping> type aliases
│   └── TestRepositories.h   # Repository classes with 4+ cache configs
├── migrations/
│   ├── 000001_create_test_items.sql
│   ├── 000004_create_test_orders.sql
│   └── 000005_create_test_events.sql  # Partitioned table (eu/us/ap)
├── config/
│   ├── test_l1_config.cpp          # Exhaustive L1 config parameter tests (TTL, refresh, cleanup)
│   └── test_l2_config.cpp          # Exhaustive L2 config parameter tests (TTL, refresh, strategy)
├── test_generated_wrapper.cpp      # Unit tests for struct + EntityWrapper + ListWrapper
├── test_base_repository.cpp        # Tests for BaseRepository (no cache) + updateBy
├── test_redis_repository.cpp       # Tests for RedisRepository (L2 cache)
├── test_cached_repository.cpp      # Tests for CachedRepository (L1 cache)
├── test_full_cache.cpp             # Tests for L1+L2 (Both) cache hierarchy interaction
├── test_decl_list_cache.cpp        # Tests for ListMixin (L1 list cache)
├── test_decl_list_redis.cpp        # Tests for declarative list caching at L2 (Redis)
├── test_decl_list_full.cpp         # Tests for declarative list caching at L1+L2 (Both)
├── test_partial_key.cpp            # Tests for PartialKey repos (composite PK, partitioned tables)
├── test_warmup.cpp                 # Tests for warmup() priming cache infrastructure
├── test_concurrency.cpp            # Concurrency stress tests across all cache levels
├── test_benchmark.cpp              # Performance benchmarks (latency, throughput)
└── test_all_runner.cpp             # Combined test executable with DrogonTestListener
```

### Mock vs Generated Models

Files in `fixtures/generated/` are auto-generated by `generate_entities.py` from `@smartrepo` annotations in the struct headers and should **not** be edited manually.

Files in `fixtures/mocks/` are **hand-maintained** mock Drogon ORM models, prefixed with `Mock_`. They mimic the interface of real `drogon_ctl`-generated models but include additional columns (e.g., JSONB composite fields) that aren't in the database schema.

## Running Tests

### All Integration Tests
```bash
ctest -L integration --output-on-failure
```

### Specific Test File
```bash
./test_smartrepo_base
./test_smartrepo_cached
```

### Specific Test Case
```bash
./test_smartrepo_base "[BaseRepository] CRUD Operations"
```

### With Verbose Output
```bash
./test_smartrepo_base -s
```

## Test Configurations

Four repository configurations are tested:

| Config      | Cache Level | Description                    |
|-------------|-------------|--------------------------------|
| `Uncached`  | None        | Direct DB access only          |
| `L1Only`    | L1          | RAM cache, no Redis            |
| `L2Only`    | L2          | Redis cache, no RAM            |
| `Both`      | L1_L2       | RAM cache backed by Redis      |

## Test Isolation

Each test section uses `TransactionGuard` which:
1. Flushes Redis at start
2. Begins a PostgreSQL transaction
3. Rolls back the transaction at end (even on failure)
4. Flushes Redis again

This ensures complete isolation between tests without leaving data behind.

## updateBy Tests

`test_base_repository.cpp` includes tests for partial field updates via `updateBy`:

- **Single field update**: Modifies only one column, verifies other columns are unchanged
- **Multiple field update**: Modifies several columns in a single call
- **Re-fetch verification**: Confirms `updateBy` returns the complete re-fetched entity from the database

These tests use `UncachedTestUserRepository` (a generated entity repository) since `updateBy` requires a generated entity with `TraitsType` containing `Field` enum and `FieldInfo` specializations. Hand-written entities (e.g., `TestItemEntity`) do not support `updateBy`.

### PartialKey updateBy

For PartialKey repos (where `Key != Model::PrimaryKeyType`), `updateBy` uses a **criteria-based** approach via `CoroMapper::updateBy(columns, criteria, values)` instead of the model dirty-flag path. This avoids the broken `setPrimaryKeyOnModel` → `getPrimaryKey()` returning an incomplete composite PK.

See `test_partial_key.cpp` sections 8a-8d for coverage at all cache levels + cross-invalidation.

## Test Tags

### `test_smartrepo_redis` (RedisRepository — L2 cache)

| Tag | Description |
|-----|-------------|
| `[item]` | Entity CRUD with Redis caching |
| `[flatbuffer]` | Binary (BEVE) serialization in Redis |
| `[updateBy]` | Partial field updates with Redis invalidation |
| `[json]` | `findByIdAsJson` raw JSON retrieval |
| `[invalidate]` | Explicit `invalidateRedis` operations |
| `[readonly]` | Read-only repository caching |
| `[cross-inv]` | `Invalidate<>` entity→entity cross-invalidation |
| `[custom-inv]` | `InvalidateVia<>` with custom resolver |
| `[readonly-inv]` | Cross-invalidation targeting read-only caches |
| `[list]` | List caching (JSON) |
| `[fb-list]` | List caching (binary) |
| `[list-inv]` | `InvalidateList<>` entity→list cross-invalidation |
| `[list-custom]` | List cross-invalidation with custom resolver |
| `[list-tracked]` | Tracked pagination with group invalidation |
| `[list-selective]` | SortBounds selective page invalidation (Lua) |
| `[list-resolver]` | `InvalidateListVia<>` with typed `GroupKey` resolver |
| `[list-granularity]` | Three granularities: per-page, per-group, full pattern |

### `test_smartrepo_decl_list_cache` (ListMixin — L1 list cache)

| Tag | Description |
|-----|-------------|
| `[query]` | Declarative list query with filters, sorts, limits |
| `[itemview]` | `ItemView` accessors on cached list results |
| `[sortbounds]` | SortBounds-based selective invalidation at L1 |
| `[tracker-cleanup]` | `ModificationTracker` cleanup cycles |

### `test_smartrepo_partial_key` (PartialKey — composite PK, partitioned tables)

| Tag | Description |
|-----|-------------|
| `[partial-key]` | All PartialKey tests |
| `[cached]` | L1 cache behavior with PartialKey |
| `[redis]` | L2 cache behavior with PartialKey |
| `[cross-inv]` | Cross-invalidation (Event as source/target) |
| `[validator]` | PartialKeyValidator runtime checks |
| `[updateBy]` | Criteria-based partial updates at all cache levels |

### `test_smartrepo_full_cache` (L1+L2 cache hierarchy)

Tests verifying interaction between RAM and Redis layers when both are active.

### `test_smartrepo_decl_list_redis` (Declarative list caching — L2)

Tests for declarative list caching at the Redis layer with filters, combined queries, and SortBounds invalidation.

### `test_smartrepo_decl_list_full` (Declarative list caching — L1+L2)

Tests for declarative list caching with both cache layers active, including cascade invalidation and cross-interaction.

### `test_smartrepo_warmup` (Warmup)

Tests for `warmup()` priming cache infrastructure including L1 entity cache and list cache initialization.

### `test_smartrepo_concurrency` (Concurrency stress tests)

| Tag | Description |
|-----|-------------|
| `[read]` | Concurrent `findById` (L1, L2, L1+L2) |
| `[read-write]` | Concurrent read + write on same entity |
| `[create-remove]` | Concurrent create + remove |
| `[cross-inv]` | Concurrent cross-invalidation |
| `[list]` | Concurrent list queries + entity creates |
| `[warmup]` | Concurrent warmup + operations |
| `[storm]` | Mixed operations storm (all operations interleaved) |
| `[updateBy]` | Concurrent `updateBy` on same entity |
| `[cleanup]` | Concurrent entity cache cleanup + reads/writes |
| `[list-cleanup]` | Concurrent list CRUD + unified `triggerCleanup`/`fullCleanup` |
| `[tracker-drain]` | `fullCleanup()` drains tracker to zero after concurrent storm |
| `[tracker-progressive]` | Progressive tracker reduction via `triggerCleanup()` |

### `config/test_l1_config` and `config/test_l2_config` (Configuration)

Exhaustive tests for individual cache configuration parameters. L1 tests cover TTL, refresh, cleanup frequency, and write restriction. L2 tests cover TTL, refresh, and update strategy variants.

### `test_smartrepo_benchmark` (Performance benchmarks)

Latency and multi-threaded throughput measurements. Separate binary, not included in standard CTest runs.